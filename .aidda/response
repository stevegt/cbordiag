<think>
Okay, I need to write a README.md for the cbordiag tool that includes usage instructions for both the CLI and the library. Let's start by looking at the existing code files provided.

First, the CLI is implemented in cmd/cbordiag/main.go. It reads CBOR data from stdin and outputs the annotated diagnostics. The main usage would be piping CBOR data into the binary. For example, something like `echo "some cbor data" | cbordiag` or using it in a pipeline with other tools.

Next, the library part is in cbordiag.go. The CborParser struct's Parse method returns the diagnostic lines. Developers would import the package, create a parser instance with their data, and call Parse() to get the formatted output.

I should start the README with a brief description of the tool, explaining its purpose. Then, include a quickstart section with installation instructions. Since it's a Go tool, installation would be via `go install` with the repository URL.

For CLI usage, examples of common scenarios would help. Like converting hex to CBOR and piping to cbordiag, or using OpenSSL to generate a certificate and parse its CBOR. Maybe also show an example using `echo` with hex data.

For the library usage, provide a short code snippet showing how to import the package, create the parser, and process data. The snippet should include handling both successful parsing and errors.

Add a section on the diagnostic format explaining the structure of each line: hex prefix, annotation, and nesting with indentation. Including an example output from one of the test cases would illustrate this well.

Testing is already covered by cbordiag_test.go, so mention running `go test -v` in the project directory.

Finally, include a note on CBOR specification references and a license section, assuming it's under MIT or similar. Ensure all code examples are properly formatted in Markdown, and check that CLI commands are accurate.

Wait, the main.go uses "strings.Join(parser.Parse(), "\n")", which joins the lines with newlines. So the CLI outputs each line separated by newlines. The README examples should reflect that output structure.

Also, the test cases have sample outputs, like the "Simple array" test. Using that as an example in the README would be consistent. Make sure to include that example with the proper indentation and annotations.

Need to verify that all commands in the examples work as written. For instance, using `echo -n "..." | xxd -r -p | cbordiag` to convert hex to binary CBOR data. Ensure that the hex examples match valid CBOR structures.

For the library example, show how to handle multiple items and error cases. Maybe parse a byte slice and print each line. Also, mention error handling, like checking for truncated data.

Check if there are any dependencies required beyond Go. Since the code uses standard libraries and no external packages except the project's own, the installation is straightforward.

Lastly, ensure that the README is comprehensive but concise, covering installation, CLI usage, library usage, examples, and references without unnecessary details.
</think>

File: /home/stevegt/lab/cbordiag/README.md
```markdown
# CBOR Diagnostic Tool

A Go implementation for parsing CBOR (Concise Binary Object Representation) data and generating annotated diagnostic output with nested structure visualization.

## Features

- Detailed annotation of CBOR data types and values
- Recursive parsing of nested structures (arrays/maps/tags)
- Error detection for truncated data
- Printable detection for byte strings
- Standard compliance with RFC 8949 specifications

## Quickstart

### Installation
```bash
go install github.com/stevegt/cbordiag/cmd/cbordiag@latest
```

### CLI Usage
Process CBOR data from stdin:
```bash
# Process hex-encoded CBOR input
echo -n "8301020382040f" | xxd -r -p | cbordiag

# Parse output from OpenSSL's cbor command
openssl cbor -in data.bin | cbordiag

# Process raw CBOR file
cbordiag < data.cbor
```

Sample output for `echo -n "8301020382040f" | xxd -r -p | cbordiag`:
```
83                   # ARRAY (3 items)
    01                   # POS INT: 1
    02                   # POS INT: 2
    03                   # POS INT: 3
82040F              # ARRAY (2 items)
    04                   # POS INT: 4
    0F                   # POS INT: 15
```

### Library Usage
```go
package main

import (
    "fmt"
    "github.com/stevegt/cbordiag"
)

func main() {
    data := []byte{0x83, 0x01, 0x02, 0x03} // CBOR array [1,2,3]
    parser := &cbordiag.CborParser{
        Data:   data,
        Offset: 0,
        Depth:  0,
    }
    
    diagnostics := parser.Parse()
    for _, line := range diagnostics {
        fmt.Println(line)
    }
    
    // Output:
    // 83                   # ARRAY (3 items)
    //     01                   # POS INT: 1
    //     02                   # POS INT: 2
    //     03                   # POS INT: 3
}
```

## Diagnostic Format
Each line follows this structure:
```
<HEX BYTES>         # <TYPE ANNOTATION> [(<DETAILS>)]
```
- **Hex Bytes**: Raw CBOR bytes in uppercase hex
- **Type Annotation**: CBOR major type and value details
- **Indentation**: 4 spaces per nesting level
- **Error Handling**: Truncated data marked with `ERROR`

## Testing
Run comprehensive tests:
```bash
go test -v ./...
```

## References
- RFC 8949: Concise Binary Object Representation (CBOR)

## License
MIT
```
EOF_/home/stevegt/lab/cbordiag/README.md

<references>
</references>
