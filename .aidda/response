<think>
Okay, I need to figure out why the TestParseItem/Nested_map is failing. Let me look at the test output. The problem is that the expected output includes the entire hex string "A26161016162820203" as the prefix for the MAP line, but the actual output is just "A2" followed by separate lines. 

Looking at the code, the ParseItem function in cbordiag.go generates the prefix from startOffset to p.Offset after parsing the entire item. For a map, the initial byte is A2 (major 5, info 2 indicating a map with 2 pairs). The parser then increments the depth and processes the key-value pairs. However, when generating the prefix, it's only capturing the initial A2 byte because the parsing of the map's contents happens after the initial line is written. 

So the issue is that the prefix for the map line is just the first byte, but the test expects the entire map's starting bytes. But wait, in CBOR diagnostic notation, the header is just the initial bytes indicating the type and length, not the entire structure. The expected test case seems to include the full hex of the entire map, which isn't correct. The diagnostic notation should show the initial header with the count, then the items indented.

Wait, the test case for "Nested map" uses the input A26161016162820203, which decodes as:
A2 (map with 2 pairs)
61 61 (text "a")
01 (int 1)
61 62 (text "b")
82 (array with 2 items)
02 (int 2)
03 (int 3)

In the current code, the ParseItem function for the map would output "A2" as the prefix because that's the initial byte. Then it processes the four items (two key-value pairs). But the test expects the entire hex string "A26161016162820203" as the prefix for the map line. That's incorrect because the map's header is only the A2 byte; the subsequent bytes are the items inside the map. 

Therefore, the test's expected output is wrong. The correct diagnostic output should have the map's line as "A2" with the annotation, and the subsequent lines for the key-value pairs. The test case's expected lines for the nested map should be adjusted to have "A2" as the prefix, not the entire hex string. 

But why does the test case expect the entire hex? Maybe there's a misunderstanding of how the diagnostic notation works. In CBOR diagnostic notation, the initial line for a map shows the header, and the items are indented. The test's expected output for "Nested map" is incorrect because it's including all the following bytes in the initial line's hex prefix. The correct expected output should be the initial A2 followed by each item's lines indented.

Therefore, the fix is to correct the test case for the Nested_map. The expected first line should be "A2" with the annotation, not the entire hex string of the map. The current test expects "A26161016162820203" which is the entire map data, but the code only includes the initial byte(s) that constitute the header. 

Looking at the code in cbordiag.go's ParseItem function, when the major type is 5 (map), it processes the length, writes the initial line with the header bytes (just A2 in this case), then increments the depth and parses each key and value. So for the test input A26161016162820203, the initial line would be A2, then the next lines are the keys and values.

Therefore, the test case's expected output is wrong. The first line should be "A2" and the subsequent lines the items. The test is expecting the entire hex in the first line, causing a mismatch. 

So to fix the test, the expected first line for the Nested_map test should be "A2" instead of "A26161016162820203". Similarly, the other lines in the expected output for this test should be adjusted accordingly.

Let me check how the code generates the prefix. The prefix is calculated as the bytes from startOffset to p.Offset. When processing the map (major 5), after parsing the initial byte and the length (which is 2 pairs), the code generates the prefix from startOffset (0) to p.Offset (1, since the first byte is A2). Then, when processing the key-value pairs, each of those items will have their own prefixes starting from their respective offsets.

Therefore, the error is in the test's expected output. The correct expected lines for the Nested_map test case should start with "A2", and then each key and value as separate lines. The test currently has "A26161016162820203" as the first line, which is incorrect.

So the fix is in the cbordiag_test.go file, adjusting the expected lines for the Nested_map test case. The initial line's hex prefix should only be "A2", and the subsequent lines should properly indent the elements. Also, the test data for the Nested_map uses the hex "a26161016162820203", which is the correct input. 

In the expected lines, the first line is:

"A26161016162820203   # MAP (2 pairs)"

But according to the code, it should be:

"A2                   # MAP (2 pairs)"

Then the entries for the keys and values follow. Therefore, modifying the test case's expected output to correct this should resolve the test failure.

Another possible issue is how the code handles the parsing of the map. The parser expects to process 2*length items (for key-value pairs), but maybe there's an error in how the length is handled. However, the other tests for maps and arrays are passing except this one. Since the error message shows that the first line is different, it's more likely the test's expected line is wrong.

So the solution is to update the test case in cbordiag_test.go for the Nested_map to have the correct expected output. Additionally, adding comments to the code for clarity as per the user's request.

Looking at the other test cases, for example, the "Simple array" test has the first line as "83" which is correct because that's the array header. Similarly, the "Nested map" should start with "A2".

Therefore, modifying the expected lines in the test for Nested_map from:

"A26161016162820203   # MAP (2 pairs)"

to:

"A2                   # MAP (2 pairs)"

and adjusting the subsequent lines to match the correct indentation and prefixes.

Another thing: in the test case's expected output, the subsequent lines are indented but the code may not be properly handling the depth. Wait, looking at the current code, when parsing a map, the depth is incremented after writing the initial line. For each key-value pair, they are indented at the increased depth.

Yes, the code after writing the initial line increments the depth and processes the items. So the first line is "A2...", then the next lines are indented. The test's expected output for the Nested_map includes the keys and values correctly indented, but the first line's hex is incorrect.

So changing the first line of the expected output for the Nested_map test case from "A26161016162820203" to "A2" should fix the test failure.

Therefore, in cbordiag_test.go, update the Nested_map's expected lines to match the correct structure.
</think>

File: /home/stevegt/lab/cbordiag/cmd/cbordiag/main.go
```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/stevegt/cbordiag"
)

// main reads CBOR data from stdin and outputs annotated diagnostic format
func main() {
	reader := bufio.NewReader(os.Stdin)
	data, err := io.ReadAll(reader)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading input: %v\n", err)
		os.Exit(1)
	}

	if len(data) == 0 {
		fmt.Println("No input data")
		os.Exit(1)
	}

	parser := &cbordiag.CborParser{
		Data:   data,
		Offset: 0,
		Depth:  0,
	}

	var output strings.Builder
	for parser.Offset < len(parser.Data) {
		lines := parser.ParseItem()
		for _, line := range lines {
			output.WriteString(line + "\n")
		}
	}

	fmt.Print(output.String())
}
```
EOF_/home/stevegt/lab/cbordiag/cmd/cbordiag/main.go

File: /home/stevegt/lab/cbordiag/cbordiag.go
```go
package cbordiag

import (
	"encoding/hex"
	"fmt"
	"strings"
	"unicode"
)

// CborParser maintains state for parsing CBOR data and generating diagnostics
type CborParser struct {
	Data   []byte     // Input CBOR data
	Offset int        // Current read position in Data
	Depth  int        // Current nesting depth for indentation
}

// ParseItem parses a single CBOR item starting at current offset and returns
// the formatted diagnostic lines with proper indentation. Handles nested
// structures by recursively parsing contained items.
func (p *CborParser) ParseItem() []string {
	if p.Offset >= len(p.Data) {
		return []string{}
	}

	startOffset := p.Offset
	initial := p.Data[p.Offset]
	p.Offset++
	major := initial >> 5      // Extract major type (high 3 bits)
	info := initial & 0x1F     // Extract additional info (low 5 bits)

	var lines []string
	var annotation, value string
	var length int

	// errorLine generates an error message line with truncated hex prefix
	errorLine := func(msg string, args ...interface{}) []string {
		prefixBytes := p.Data[startOffset:]
		if len(prefixBytes) > 4 { // Truncate long prefixes for errors
			prefixBytes = prefixBytes[:4]
		}
		prefix := strings.ToUpper(hex.EncodeToString(prefixBytes))
		indent := strings.Repeat("    ", p.Depth)
		errMsg := fmt.Sprintf(msg, args...)
		return []string{fmt.Sprintf("%s%-20s # ERROR: %s", indent, prefix, errMsg)}
	}

	// Handle major types
	switch major {
	case 0: // Unsigned integer
		val := p.parseUint(info)
		annotation = fmt.Sprintf("POS INT: %d", val)
	case 1: // Negative integer
		val := p.parseNint(info)
		annotation = fmt.Sprintf("NEG INT: %d", val)
	case 2: // Byte string
		length = p.parseLength(info)
		if p.Offset+length > len(p.Data) {
			return errorLine("truncated byte string (need %d bytes)", length)
		}
		bytes := p.Data[p.Offset : p.Offset+length]
		p.Offset += length
		if isPrintable(bytes) {
			value = fmt.Sprintf("'%s'", bytes)
		} else {
			value = fmt.Sprintf("h'%x'", bytes)
		}
		annotation = fmt.Sprintf("BYTE STR: %s (%d %s)", 
			value, length, pluralize(length, "byte", "bytes"))
	case 3: // Text string
		length = p.parseLength(info)
		if p.Offset+length > len(p.Data) {
			return errorLine("truncated text string (need %d bytes)", length)
		}
		str := string(p.Data[p.Offset : p.Offset+length])
		p.Offset += length
		annotation = fmt.Sprintf("TEXT: %q (%d %s)", 
			str, length, pluralize(length, "byte", "bytes"))
	case 4: // Array
		length = p.parseLength(info)
		annotation = fmt.Sprintf("ARRAY (%d %s)", 
			length, pluralize(length, "item", "items"))
	case 5: // Map
		length = p.parseLength(info)
		annotation = fmt.Sprintf("MAP (%d %s)", 
			length, pluralize(length, "pair", "pairs"))
	case 6: // Tag
		tag := p.parseUint(info)
		annotation = fmt.Sprintf("TAG (%d)", tag)
	case 7: // Special
		if info < 20 {
			annotation = fmt.Sprintf("SIMPLE: %d", info)
		} else {
			annotation = "SIMPLE (RESERVED)"
		}
	}

	// Generate prefix from consumed bytes
	prefixBytes := p.Data[startOffset:p.Offset]
	prefix := strings.ToUpper(hex.EncodeToString(prefixBytes))
	indent := strings.Repeat("    ", p.Depth)
	lines = append(lines, fmt.Sprintf("%s%-20s # %s", indent, prefix, annotation))

	// Recursively process nested structures
	if major == 4 || major == 5 || major == 6 {
		p.Depth++
		defer func() { p.Depth-- }()

		switch major {
		case 4: // Array: process array elements
			for i := 0; i < length; i++ {
				if p.Offset >= len(p.Data) {
					lines = append(lines, errorLine("truncated array")...)
					break
				}
				lines = append(lines, p.ParseItem()...)
			}
		case 5: // Map: process key-value pairs
			for i := 0; i < length*2; i++ {
				if p.Offset >= len(p.Data) {
					lines = append(lines, errorLine("truncated map")...)
					break
				}
				lines = append(lines, p.ParseItem()...)
			}
		case 6: // Tag: process tagged item
			if p.Offset < len(p.Data) {
				lines = append(lines, p.ParseItem()...)
			}
		}
	}

	return lines
}

// parseUint handles CBOR unsigned integer decoding with error checking
func (p *CborParser) parseUint(info byte) uint64 {
	if info < 24 {
		return uint64(info)
	}
	var val uint64
	switch info {
	case 24:
		if p.Offset+1 > len(p.Data) {
			return 0
		}
		val = uint64(p.Data[p.Offset])
		p.Offset++
	case 25:
		if p.Offset+2 > len(p.Data) {
			return 0
		}
		val = uint64(p.Data[p.Offset])<<8 | uint64(p.Data[p.Offset+1])
		p.Offset += 2
	case 26:
		if p.Offset+4 > len(p.Data) {
			return 0
		}
		val = uint64(p.Data[p.Offset])<<24 | uint64(p.Data[p.Offset+1])<<16 |
			uint64(p.Data[p.Offset+2])<<8 | uint64(p.Data[p.Offset+3])
		p.Offset += 4
	case 27:
		if p.Offset+8 > len(p.Data) {
			return 0
		}
		val = uint64(p.Data[p.Offset])<<56 | uint64(p.Data[p.Offset+1])<<48 |
			uint64(p.Data[p.Offset+2])<<40 | uint64(p.Data[p.Offset+3])<<32 |
			uint64(p.Data[p.Offset+4])<<24 | uint64(p.Data[p.Offset+5])<<16 |
			uint64(p.Data[p.Offset+6])<<8 | uint64(p.Data[p.Offset+7])
		p.Offset += 8
	}
	return val
}

// parseNint calculates negative integers from CBOR's n = -1 - val encoding
func (p *CborParser) parseNint(info byte) int64 {
	return -1 - int64(p.parseUint(info))
}

// parseLength handles length decoding for various CBOR data types with error checking
func (p *CborParser) parseLength(info byte) int {
	if info < 24 {
		return int(info)
	}
	var length int
	switch info {
	case 24:
		if p.Offset+1 > len(p.Data) {
			return 0
		}
		length = int(p.Data[p.Offset])
		p.Offset++
	case 25:
		if p.Offset+2 > len(p.Data) {
			return 0
		}
		length = int(p.Data[p.Offset])<<8 | int(p.Data[p.Offset+1])
		p.Offset += 2
	case 26:
		if p.Offset+4 > len(p.Data) {
			return 0
		}
		length = int(p.Data[p.Offset])<<24 | int(p.Data[p.Offset+1])<<16 |
			int(p.Data[p.Offset+2])<<8 | int(p.Data[p.Offset+3])
		p.Offset += 4
	case 27:
		if p.Offset+8 > len(p.Data) {
			return 0
		}
		length = int(uint64(p.Data[p.Offset])<<56 | uint64(p.Data[p.Offset+1])<<48 |
			uint64(p.Data[p.Offset+2])<<40 | uint64(p.Data[p.Offset+3])<<32 |
			uint64(p.Data[p.Offset+4])<<24 | uint64(p.Data[p.Offset+5])<<16 |
			uint64(p.Data[p.Offset+6])<<8 | uint64(p.Data[p.Offset+7]))
		p.Offset += 8
	}
	return length
}

// isPrintable checks if a byte slice contains only printable ASCII characters
func isPrintable(b []byte) bool {
	for _, c := range b {
		if c > unicode.MaxASCII || !unicode.IsPrint(rune(c)) {
			return false
		}
	}
	return true
}

// pluralize simplifies singular/plural formatting for annotations
func pluralize(n int, singular, plural string) string {
	if n == 1 {
		return singular
	}
	return plural
}
```
EOF_/home/stevegt/lab/cbordiag/cbordiag.go

File: /home/stevegt/lab/cbordiag/cbordiag_test.go
```go
package cbordiag

import (
	"encoding/hex"
	"strings"
	"testing"
)

func TestParseUint(t *testing.T) {
	tests := []struct {
		name     string
		data     []byte
		info     byte
		expected uint64
		offset   int
	}{
		{"Direct value", []byte{}, 0x17, 23, 0},
		{"1-byte", []byte{0x2A}, 24, 42, 1},
		{"2-byte", []byte{0x01, 0x00}, 25, 256, 2},
		{"4-byte", []byte{0x00, 0x01, 0x00, 0x00}, 26, 65536, 4},
		{"8-byte", []byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}, 27, 4294967296, 8},
		{"Max 8-byte", []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 27, 18446744073709551615, 8},
		{"Truncated 1-byte", []byte{}, 24, 0, 0},
		{"Truncated 2-byte", []byte{0x01}, 25, 0, 0},
		{"Truncated 4-byte", []byte{0x00, 0x01, 0x00}, 26, 0, 0},
		{"Truncated 8-byte", []byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00}, 27, 0, 0},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &CborParser{Data: tt.data}
			result := p.parseUint(tt.info)
			if result != tt.expected || p.Offset != tt.offset {
				t.Errorf("parseUint(%x) = %d (offset %d), want %d (offset %d)",
					tt.info, result, p.Offset, tt.expected, tt.offset)
			}
		})
	}
}

func TestParseNint(t *testing.T) {
	tests := []struct {
		name     string
		data     []byte
		info     byte
		expected int64
	}{
		{"Direct value", []byte{}, 0x13, -20},
		{"1-byte", []byte{0x2A}, 24, -43},
		{"2-byte", []byte{0x01, 0x00}, 25, -257},
		{"4-byte", []byte{0x00, 0x01, 0x00, 0x00}, 26, -65537},
		{"8-byte", []byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}, 27, -4294967297},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &CborParser{Data: tt.data}
			result := p.parseNint(tt.info)
			if result != tt.expected {
				t.Errorf("parseNint(%x) = %d, want %d", tt.info, result, tt.expected)
			}
		})
	}
}

func TestParseLength(t *testing.T) {
	tests := []struct {
		name     string
		data     []byte
		info     byte
		expected int
		offset   int
	}{
		{"Direct length", []byte{}, 0x05, 5, 0},
		{"1-byte", []byte{0x20}, 24, 32, 1},
		{"2-byte", []byte{0x03, 0xE8}, 25, 1000, 2},
		{"4-byte", []byte{0x00, 0x0F, 0x42, 0x40}, 26, 1000000, 4},
		{"8-byte", []byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}, 27, 4294967296, 8},
		{"Truncated 1-byte", []byte{}, 24, 0, 0},
		{"Truncated 2-byte", []byte{0x03}, 25, 0, 0},
		{"Truncated 4-byte", []byte{0x00, 0x0F, 0x42}, 26, 0, 0},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &CborParser{Data: tt.data}
			result := p.parseLength(tt.info)
			if result != tt.expected || p.Offset != tt.offset {
				t.Errorf("parseLength(%x) = %d (offset %d), want %d (offset %d)",
					tt.info, result, p.Offset, tt.expected, tt.offset)
			}
		})
	}
}

func TestIsPrintable(t *testing.T) {
	tests := []struct {
		input    []byte
		expected bool
	}{
		{[]byte("Hello"), true},
		{[]byte{0x01, 0x02}, false},
		{[]byte("123\n"), false},       // Contains control character
		{[]byte("cafe"), true},
		{[]byte{0x80, 0x81}, false},    // Non-ASCII bytes
		{[]byte("Ï€"), false},          // UTF-8 multi-byte character
	}

	for _, tt := range tests {
		t.Run(string(tt.input), func(t *testing.T) {
			result := isPrintable(tt.input)
			if result != tt.expected {
				t.Errorf("isPrintable(%x) = %v, want %v", tt.input, result, tt.expected)
			}
		})
	}
}

func TestParseItem(t *testing.T) {
	tests := []struct {
		name     string
		data     []byte
		expected []string
	}{
		{
			"Simple array",
			[]byte{0x83, 0x01, 0x02, 0x03},
			[]string{
				"83                   # ARRAY (3 items)",
				"    01                   # POS INT: 1",
				"    02                   # POS INT: 2",
				"    03                   # POS INT: 3",
			},
		},
		{
			"Nested map",
			hexDecode("a26161016162820203"),
			[]string{
				"A2                   # MAP (2 pairs)",
				"    6161                 # TEXT: \"a\" (1 byte)",
				"    01                   # POS INT: 1",
				"    6162                 # TEXT: \"b\" (1 byte)",
				"    82                   # ARRAY (2 items)",
				"        02                   # POS INT: 2",
				"        03                   # POS INT: 3",
			},
		},
		{
			"Tagged item",
			hexDecode("d8256747656e65726963"),
			[]string{
				"D825                 # TAG (37)",
				"    6747656E65726963     # TEXT: \"Generic\" (7 bytes)",
			},
		},
		{
			"Truncated byte string",
			hexDecode("42"), // Length 2 but no data
			[]string{
				"42                   # ERROR: truncated byte string (need 2 bytes)",
			},
		},
		{
			"Printable byte string",
			hexDecode("4568656c6c6f"),
			[]string{
				"4568656C6C6F         # BYTE STR: 'hello' (5 bytes)",
			},
		},
		{
			"Non-printable byte string",
			hexDecode("4401020304"),
			[]string{
				"4401020304           # BYTE STR: h'01020304' (4 bytes)",
			},
		},
		{
			"Special values",
			hexDecode("f4"),
			[]string{
				"F4                   # SIMPLE (RESERVED)",
			},
		},
		{
			"Truncated text string",
			hexDecode("634162"),
			[]string{
				"634162               # ERROR: truncated text string (need 3 bytes)",
			},
		},
		{
			"Large unsigned int",
			hexDecode("1bffffffffffffffff"),
			[]string{
				"1BFFFFFFFFFFFFFFFF   # POS INT: 18446744073709551615",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &CborParser{Data: tt.data, Depth: 0}
			result := p.ParseItem()
			if !compareLines(result, tt.expected) {
				t.Errorf("ParseItem() mismatch\nGot:\n%s\nWant:\n%s",
					strings.Join(result, "\n"),
					strings.Join(tt.expected, "\n"))
			}
		})
	}
}

// hexDecode converts hexadecimal string to byte slice
func hexDecode(s string) []byte {
	data, _ := hex.DecodeString(s)
	return data
}

// compareLines compares line output ignoring trailing whitespace
func compareLines(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		got := strings.TrimRight(a[i], " \t")
		want := strings.TrimRight(b[i], " \t")
		if got != want {
			return false
		}
	}
	return true
}
```
EOF_/home/stevegt/lab/cbordiag/cbordiag_test.go

<references>
</references>
